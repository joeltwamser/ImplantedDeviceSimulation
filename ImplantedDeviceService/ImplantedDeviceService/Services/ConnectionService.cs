using Grpc.Core;
using ImplantedDeviceService;

namespace ImplantedDeviceService.Services
{
    public class ConnectionService : Connection.ConnectionBase
    {
        private readonly ILogger<ConnectionService> _logger;
        //Eventually change this and register MyCosine class as a singleton service instead
        //This currently is not as flexible as using dependency injecetion.
        private readonly MyCosine _my_cosine;

        public ConnectionService(ILogger<ConnectionService> logger, MyCosine my_cosine)
        {
            _logger = logger;
            _my_cosine = my_cosine;
        }

        //I still have not decided if I should even have my own point class or not
        //It feels like to me I should, because I should not couple the backend behavior
        //of this server app to the classes generated by the proto file.  But maybe I'm wrong.
        private GraphSamples CreateGraphSamplesObject()
        {
            List<MyPoint> points = _my_cosine.GetSamples();
            var graph_samples = new GraphSamples();
            foreach (MyPoint point in points)
            {
                Point p = new()
                {
                    X = point.X,
                    Y = point.Y
                };
                graph_samples.Samples.Add(p);
            }
            return graph_samples;
        }

        public override Task<GraphSamples> Initialization(Initialize request, ServerCallContext context)
        {
            if (request.InitMessage == "BeginInit")
            {
                _my_cosine.SampleCount = 500;
                _my_cosine.SampleRate = 1000;
                _my_cosine.Amplitude = 1;
                _my_cosine.Frequency = 1;
                _my_cosine.PhaseShift = 0;
                _my_cosine.VerticalShift = 0;
                //This might be unnecessary to have my own local implementation of a Point class, and then the proto version of
                //a point.  But for argument's sake, just incase these two were different and needed a middle step to be copied
                //and/or transcribed
                var graph_samples = CreateGraphSamplesObject();
                return Task.FromResult(graph_samples);
            }
            else
            {
                return base.Initialization(request, context);
            }
        }

        public override Task<GraphSamples> FrequencyChange(Frequency request, ServerCallContext context)
        {
            _my_cosine.Frequency = request.CyclesPerSecond;
            var graph_samples = CreateGraphSamplesObject();
            return Task.FromResult(graph_samples);
        }

        public override Task<GraphSamples> PhaseChange(Phase request, ServerCallContext context)
        {
            _my_cosine.PhaseShift = request.Number;
            var graph_samples = CreateGraphSamplesObject();
            return Task.FromResult(graph_samples);
        }
    }
}